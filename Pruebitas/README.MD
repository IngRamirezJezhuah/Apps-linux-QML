# Documentacion de qml para no perderme


# Puntos Clave:

>import: Le dice a QML qu√© componentes cargar. QtQuick tiene los b√°sicos (Rectangle, Text, Image) y QtQuick.Controls tiene los modernos (Button, TextField, Slider).

>id: Es un nombre √∫nico (dentro de este archivo) para poder referenciar un elemento desde otro.

>Propiedad: valor: As√≠ se asigna todo.

>Anidaci√≥n: Poner un Text dentro de ApplicationWindow lo hace su "hijo". La parent (padre) del Text es la ApplicationWindow.

## El superpoder de QML : "Property Bidings" (Enlaces)


>>Este es el concepto m√°s importante de QML. Un enlace (binding) no es una asignaci√≥n de una sola vez, es una relaci√≥n permanente. Se usa el s√≠mbolo de dos puntos (:). Ejemplo SIN binding (Malo):

### QML

Rectangle {
    width: 100 // width siempre ser√° 100
}

Ejemplo CON binding (¬°M√°gico!):

QML :

    ApplicationWindow {
        id: rootWindow
        width: 640
        height: 480

        Rectangle {
            id: myRect
            color: "lightblue"

            // === ¬°EL BINDING! ===
            // "width" siempre ser√° la mitad del ancho de la ventana.
            // Si redimensionas la ventana, ¬°el rect√°ngulo se ajustar√° solo!
            width: rootWindow.width / 2 
            
            // "height" siempre ser√° igual a su propio "width"
            height: width // QML entiende que te refieres al "width" de myRect
            
            anchors.centerIn: parent
        }
    }
¬°No tuviste que escribir c√≥digo para "manejar el evento de redimensi√≥n"! Simplemente declaraste la relaci√≥n. QML se encarga del resto.

# Posicionamiento: Layouts (La Forma Correcta)

>>Nunca posiciones cosas con x: 10 y y: 20. Es una pesadilla de mantener. Siempre usa Layouts (contenedores) o Anchors (anclas).

$ Column: Apila hijos verticalmente.

$Row: Apila hijos horizontalmente.

$GridLayout: Una cuadr√≠cula.

QML

    ApplicationWindow {
        // ... (width, height, visible, title)

        // Un layout de Columna que ocupa toda la ventana
        Column {
            anchors.fill: parent // Haz que la columna ocupe toda la ventana
            anchors.margins: 10  // Con un margen de 10px
            spacing: 5           // Espacio de 5px entre cada hijo

            Text {
                text: "Nombre:"
                font.bold: true
            }
            
            TextField { // Un campo para escribir texto
                id: nameInput
                placeholderText: "Escribe tu nombre aqu√≠"
                // El layout se encarga del 'y', nosotros del 'width'
                width: parent.width // Que ocupe todo el ancho de la columna
            }
            
            Button {
                text: "Saludar"
                anchors.horizontalCenter: parent.horizontalCenter // Centra solo este bot√≥n
            }
        }
    }

# Interactividad: Se√±ales y Eventos (JavaScript)

>>C√≥mo respondes a un clic? Usando "manejadores de se√±ales" (signal handlers). Son funciones que empiezan con on... Cualquier c√≥digo que escribes dentro de un manejador de se√±al es JavaScript.

QML

    Column {
        // ... (anclas, espaciado)
        
        TextField {
            id: nameInput
            width: parent.width
            placeholderText: "Escribe tu nombre"
        }

        Text {
            id: greetingLabel
            text: "Esperando..."
            anchors.horizontalCenter: parent.horizontalCenter
        }

        Button {
            id: myButton
            text: "Saludar"
            anchors.horizontalCenter: parent.horizontalCenter
            
            // El manejador de evento "clic"
            onClicked: {
                // Esto es JavaScript
                console.log("¬°Bot√≥n presionado!")
                
                // ¬°Podemos cambiar propiedades de otros elementos!
                // Gracias al 'id', podemos referirnos a ellos
                greetingLabel.text = "¬°Hola, " + nameInput.text + "!"
                greetingLabel.color = "blue"
            }
        }
    }

# Creando una App "Funcional" (Conectando a C++) üîß

>>Aqu√≠ es donde se une todo. Quieres que QML maneje el clic, pero que C++ haga el trabajo pesado (como guardar un archivo).

$Paso 1: El "Backend" en C++
Crea una nueva clase en C++ que herede de QObject. Esta ser√° tu "API" para QML.

(Ejemplo) AppBackend.h

    #ifndef APPBACKEND_H
    #define APPBACKEND_H

    #include <QObject>
    #include <QDebug>
    #include <QString>

    class AppBackend : public QObject
    {
        Q_OBJECT // Macro obligatoria para se√±ales, slots y Q_INVOKABLE

    public:
        explicit AppBackend(QObject *parent = nullptr) : QObject(parent) {}

        // ¬°La funci√≥n m√°gica!
        // Q_INVOKABLE permite que QML llame a esta funci√≥n de C++
        Q_INVOKABLE void saveMessage(const QString &message)
        {
            // Aqu√≠ ir√≠a tu l√≥gica real de C++ (ej. QFile, QNetworkRequest)
            // Por ahora, solo imprimimos a la consola de depuraci√≥n
            qDebug() << "C++ RECIBI√ì EL MENSAJE:" << message;
            qDebug() << "Simulando guardado en /home/djxs4n/documento.txt...";
            // ... l√≥gica de guardado ...
        }
    };

    #endif // APPBACKEND_H

